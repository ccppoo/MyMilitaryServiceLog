## 객체에게 책임 할당하기

지금까지 읽은 객체지향적 설계는 사람이 사는 사회와 원리가 매우 유사하다.

추상적인 사람이 구체적인 기계를 만들고, 구체적인 기계를 가지고 프로그래밍을 사람이 만드니

사람의 인지과정에 더 가깝게 설계되는게 자연스러운 것 같기도 하다.

...

객체는 단지 데이터를 저장하기 위한 구조체가 아니다.

객체는 필요(수요)가 있는 다음에 제작(공급)이 이루어지고, 필요에 따른 책임이 주어진다.

주어진 고유한 기능만을 수행하고, 객체가 가지고 있지 않은 기능이 필요하다면 해당 기능을 가진 다른 객체와 협력한다.

협력은 객체간 메세지를 통해서 이루어지는데, 협력을 제공하는 객체(B)에 대해서 협력을 요청하는 객체(A)가 <br>
객체 B의 세부적인 사항까지 알 필요가 없도록 협약(프로토콜, Protocol)을 만든다.

협약은 다른 말로 흔히 쓰는 인터페이스(Interface)다.

글을 쓰다보니 왜 Swift에서 인터페이스(interface) 대신 프로토콜(Protocol)이라고 불르는지 이해를 할 수 있었다.

인터페이스는 유명한 패키지 라이브러리가 가지고 있는 Document와 같다.

사용자가 사용할 수 있는 메서드 이름, 리턴값, 파라미터, 던지는 에러 등

객체, 메서드를 사용하는 도중 **사용자가 겪게될 것들**을 알려주는 것과 같다.

...


평상시 우리가 물을 쓰는데 정작 물이 어떻게 정제되며 어떤 수도를 따라 들어오는지 관심을 안주는 것과 같다.

**수도꼭지만 열면 우리는 물이 나올것이라는 기대를 하고 사용하고 있다**.

수도꼭지를 연다는 것을 지킨다면 우리는 물이 나올것이라고 기대하듯이

객체를 이용하는 다른 객체와 설계자들 또한 사용하는 방법만을 지키면 리턴값을 받게 될거라고 믿고 작동, 설계할 것이다.

그리고 이 기대를 부합하기 위해서 객체 설계자들은 인터페이스만 만족시키면

각자 알아서 만들면된다.

------

### 인간적인(?) 예시로 이해하기

* 회사 직원은 각자 회사가 돌아가는데 필요한 기능으로서 채용된다. - 객체 생성
* 사장은 개발부에 일을 시키고, 그에 대한 결과를 기대한다, 일이 내부에서 어떻게 돌아가는지 딱히 신경안쓴다 - 메세지, 인터페이스, 은닉성
* 다른 직원이 교체되어 할일만 잘 하면 다른 부서에서는 신경 안써도 된다. - 응집성 up
* 만약 다른 부서의 사람이 직접 개발부에 들어와 일을 같이 병행을 하다 쓰러지면 그 능력자를 대체할 사람이 없어 차질이 생긴다 - 결합도 up
* 그래서 직원에게 알맞고 다른 분야의 일을 무리해서 시키지 않는다, 전체적으로 그 직원에 의존성이 낮아진다 - 결합도 down
* 직원에게 일을 시켰으면 알아서 처리하게끔 냅둬라 - 자율성 up

다형성(Polymorphism)과 변수 은닉(Protected Variations)
변경될 여지가 많거나 추가/제거될 수 있는 것들은 객체 내부에서 외부로 **약속된** 형식으로 리턴한다는 것을 정하자.
<br> if/else/switch와 같은 조건문은 제자하자.

변수 이름이나 임시로 만든 메서드와 같이 변경될 가능성이 높다면 직접 노출하지 말고

인터페이스 또는 변경 가능성이 낮은 메서드를 통해 사용하게끔 만들자.
------

### 정리

	1. 객체는 필요에 따라 생성하고, 그 필요에 맞는 기능과 데이터를 알아서 처리한다.
	
	2. 객체 이용자들이 객체 내부에 대해서 알 필요없도록 갖고 있는 기능에 대한 스펙을 공개하고 제시한다(인터페이스)
		2-1. 제공한 인터페이스를 지키기만 한다면 그 리턴값은 보장한다.
	
	3. 객체는 다른 객체에 대해 정보를 최소한으로 공개한다(은닉성).
	
	4. 객체에 어올리지 않은 기능 또는 데이터가 추가 될 예정이면 새로운 객체를 위의 규칙에 따라 만든다.
	

1. 절차지향에서 객체지향으로 - C에서 객체로 전환

절차지향 프로그래밍의 대명사인 C언어는 객체지향 프로그래밍의 클래스보다 원시적인 구조체(Struct)를 갖고 있다.
구조체는 필요한 데이터를 연속된 메모리 구간에 일정한 형태로 묶어 놓은 것이라고 볼 수 있다.
비유를 하자면, 각각 실수로 표현 할 수 있는 세 과목의 성적을 한번에 담을 수 잇는 자료형을 기존하는 실수
자료형(double)을 묶어 새로운 이름의 자료형을 만드는 것과 같다.
이를 이용해 학생의 성적을 기록할 때 매번 3개의 실수 자료형을 일일히 만들 필요없이 다음과 같이 하나의 구조체로 값을 저장할 수 있다.

typedef struct Score {
    double math;
    double science;
    double language;
} Score;

C를 접해보지 않은 사람들이 본다면 하나의 클래스(Class)와 비슷하게 보이는 것은 자연스럽다.
하지만 말했듯이 구조체는 단지 하나의 자료형에 불구하고, 더군다나 내가 쓰려고 직접 만든 '자료형'이기 때문에 원래부터 C
기본 라이브러리에 있는 int, double, char과 같은 기존 자료형들을 위한 이미 만들어진 함수가 존재하지 않는다.
그래서 오직 이 자료형을 편리하게 사용하기 위해서 만드는 함수들이 소속 등장하게 된다.

성적(Score) 구조체를 쓰다보면 사용자들은 어떤 값들을 사용하게 될까?
아무래도 성적이라고 하면 평균값을 반환하는 함수를 만들 가능성이 있다.
Struct 자료형만을 위한 함수를 만드는 것이다!

double getScoreAverage(Score *scr){
     return (scr.math + scr.sciecne + sce.language)/3;
}

사용시 :
Score kim = {80.5, 90.0, 95.0};
printf("Average is : %f", getScoreAverage(&kim));

이를 이용해 사용자는 Score이라는 구조체를 사용해서 '직접 내용물을 조작하거나 다룰 필요 없이' 평균을 함수를 통해 구할 수 있다.
위에서 만든 getScoreAverage 함수를 통해서 구조체의 구조와 함수의 구체적인 내용을 알 필요가 없다.
이와 같은 함수를 '인터페이스 함수'라고 한다.

실물로 예시를 들자면, 자동차 핸들을 떠올리면 된다.
좌우로 돌리면 사용자는 자동차 내부 구조(구조체의 구조)나 좌우로 돌릴 때 자동차 내부에서 작동되는 원리(함수의 구체적인
내용)를 알 필요없이, 자동차가 좌우로 가는 것만 확인하면 된다.

인터페이스에 대해서 어색하다면 많이 들어봤을 법한 UI(User Interface)를 생각하면 쉽다.
컴퓨터를 작동시키기 위해 명령어를 쳐야했던 검은 화면에서, 이제는 클릭 몇번으로 쉽게 컴퓨터를 사용할 수 있는 것이다.

이처럼 일반 사용자들은 UI가 편리하듯이 프로그래머들은 "통일된" interface가 편리하다.

그래서 getScoreAverage는 오직 Score 구조체만을 위한 것인데 Score 구조체 내부에 포함시키면 안될까? 한 것이 아래와 같다.

typedef struct Score {
    double math;
    double science;
    double language;
    double (* getAverage)(struct Score*);
} Score;

함수 포인터(자료형)를 통해서 실수 자료형 중 하나인 수학성적(double math)처럼 하나의 값으로 지정할 수 있다.
하지만 아직 함수 포인터에 값을 대입한 것이 아니다.
위 상황은 다음과 같이 표현 할 수 있다.
"하나의 큰 상자가 있는데, 거기에는 4개의 칸이 있어. 3개는 각각 "math", "science", "language"라는
이름을 가진 실수를 담을 수 있는 칸이야."
"다른 하나는 Score 구조체 자료형 하나를 변수로 받고 실수를 반환하는 "getAverage"이라는 함수 포인터를 담을 수 있는 칸이야"

여기서 주의할 점은 "getAverage"이라는 함수 포인터 칸이 있다는 것 뿐이지, 꼭 평균값을 반환할 거라는
함수(getScoreAverage)가 있는 것이 아니다.
매번 Score 구조체를 선언할 때 마다 값을 초기화해야 하기 때문에 실수할 가능성이 있으며,
협업을 하는 경우 다른 팀원들이 이미 만들어진 getScoreAverage 함수 대신 다른 것을 넣어 중복된 일을 할 수 있는 가능성이 높다.

그리고 더 충격적인 것은 getAverage 함수를 호출하는 방법이다.

double getScoreAverage(Score* scr){ ... }
Score kim = {85.0, 90.0, 95.0, getScoreAverage }; // Score 구조체 kim 변수 초기화
printf("%.1f", kim.getAverage(&kim)); // --> 90.0 (평균값 반환)

Score 객체 kim을 초기화 하고, getAverage를 호출할 때 kim이 소유하고 있는 getAverage를 사용하기
위해서 변수에 kim을 써야하는 것이다.
kim이 갖고 있는 함수를 쓰기 위해서 kim 변수 스스로를 부른다....

현실적인 예시를 든다면, 서울시에 속해있는 공무원에게 일을 시키는데 공무원에게 "대한민국 서울특별시 공무원이 지시받은 일을
해라"라고 해야 알아 듣는다는 것이다.
kim(서울특별시)에 속해있는 함수 getAverage(일해라)를 수행하는데, 변수 값으로 &kim(서울특별시에서)를 대입한 것과 같다.
직관적으로 생각하면, 서울시에 속해있는 공무원에게 일을 시키면 당연히 서울 행정업무를 하는 것이 당연하다.

뭔가 이상하지 않은가? 이런 당연스러움을 해결해 주는 것이 객체다.

파이썬으로 예를 들면

class Score():
    def Score(mathScore, scienceScore, languageScore):
        self.math = mathScore
        self.science = scienceScore
        self.language = languageScore
    def getAverage(self):
        return (self.math + self.science + self.language)/3

kim = Score(85.0,  90.0, 95.0)
kim.getAverage()        # --> 90.0

자기 자신(객체 변수)을 가르키는 "self"가 포인터(C의 관점에서)다.
kim.getAverage()와 같이 생략이 가능하다. 객체 변수 자기 자신을 가르키는 것이라고 컴파일러는 다 알고 있으니깐.
점(dot) 연산자가 어색하다면, 읽을 때 점('.')을 '의'로 바꿔서 읽는 것과 같다.

kim.getAverage() == kim의 getAverage 함수 실행


....


더 이상 C에서 객체지향이 어떻게 파생되었는지 원록적인 이야기를 할 여력이 없다.
추상적이고 너무나 자연스러운 발달 과정을 거친 것 중 하나라 마치 유인원에서 인류로 진화하는 과정을 설명하는 느낌이다.
나의 단편적인 지식으로 완벽한 발달 과정을 설명하지 못하겠다.
더 근본적인 원리, 일반인들이 자연스럽게 납득 할 만한 옛는 생각이 나면 추가하겠다.
위의 설명이 부족하지만, 체감하면서 이해하는 과정(실무에서 이론파생)이 더 효과적이라고 생각한다.
C언어의 구조체를 이용하면 객체의 필요성을 느낄 수 있을 것이다.

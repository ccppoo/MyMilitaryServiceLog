# 알고리즘의 중요성 - 문득 생각난 이야기

알고리즘이라고 하면 가장 최적화된 방법이다.

반복된 연산을 하는 컴퓨터의 특징을 가장 최적화된 방법으로 활용하는 방법이라고 나는 설명한다.

그래서 모든 회사가 알고리즘을 입사 시험으로 치르는 것에 대해 난 거부감이 들었다.

'아니 왜 최적화된 방법을 고르는 것을 시험으로 치루지? 

차라리 DB 설계라던가 가상의 실무 상황을 주고 어떻게 해결하는지 보는게 접근법 차원에서 더 유연한 사고를 판단하는게 아닐까?'

프로그래밍을 접하고나서부터 이런 의문을 가지고  내내 살아왔다.

무작정 알고리즘을 수능 공부하듯이 공부를 하는 취준생, 알고리즘 학원을 보면 마치

조선시대 실용학을 천대시하고 성리학과 유교를 최우선시하는 모습을 보는 것 같았다.

최적화라는 개념은 모든 개발이 진행되고 나서 튜닝하듯이 맨 마지막에 하는 것이 당연한 프로세스 과정이라고 생각했기 때문이다.

지금도 이런 생각으로 가득 차있는 것은 아지만, 얼핏 맞는 부분이라고 생각한다.

설계를 문서화한 기획서만 있다면 최적화는 전문적으로 상위 1%의 인력으로 단계를 분업화하는 것이 더 효율적인 것 같기 떄문이다.

## 문득 생각이

이런 의문에 스스로 궁금증을 해결한 것은 알고리즘과 직접적인 관련성이 적은 커널을 공부했을 때다.

마침 리눅스 시스템 포크(fork)에 대해 찾아보고 있는 도중 문득 생각이 든 것이다.

낮은 수준의 언어로 작성되는 커널에서는 단순히 ```printf```를 하는데 수많은 과정이 오고 간다.

어셈블리어부터 시작하는 하드웨어를 인간이 알아볼 수 있는 단계의 추상화까지 올리는데 거치는 과정이다.

하지만 반복문 그리고 반복문의 내부를 최적화된 방법없이 사용된다면 아무리 미미한 작업일지언정

낭비되는 프로세스가 급속히 증가되는 것은 불보듯 뻔했다.

커널을 작성할 프로그래머라면 높은 숙련도와 이해도를 가진다.

이들이 최적화된 방법으로 작성하지 않아도 개인이 사용하는 수준에서는 눈에 보이지도 않는다.

인터넷이 연결된 브라우저를 하나 여는데 2~3초 정도는 거뜬히 기다려주는 일반 사용자는 관대하기 떄문이다.

## 그래서

왜 알고리즘 테스트가 유의미한 척도로 쓰이는지 결론을 내린 이유는

대부분의 프로그래머들은 ASM, C/C++ 같이 메모리를 직접 관리해야할 만큼 낮은 추상화 단계의 언어를 사용하지 않기 떄문이다.

편리한 만큼 속도나 성능면에서 불이익을 받는다.

하지만, 개발이나 유지보수에 들이는 시간에 비해 미미하기 때문에 대부분의 회사는 이보다 더 높은 추상화 단계의 언어를 사용한다.

Java, Node.js, Python, 등 메모리까지 직접 관리해주는 관대한 언어들이다.

높은 추상화 단계의 언어가 성능까지 내주면서 편리한 인터페이스를 제공하는 만큼 사용하는 인간에게서

**우리는 편리하게 해줄 만큼 해줬으니 너네 선에서 할 수 있는 것은 해라**라고 요구하는 것처럼 들린다.

예를 들어 Python과 동일한 작업을 하는 C/C++로 작성된 쓰레기 코드는 어지간히 해서 느릴 수가 없다.

컴퓨터의 주된 작업은 반복하는 작업이다.

배열안에서 필요한 데이터를 조회하거나, 정렬을 하거나, 출력을 하는 것이다.

반복되는 일이 많은 만큼 반복하는 일들에 있어서 최소한의 자원으로 최대한의 성능을 뽑아야한다.

언어 설계 내부를 아무리 잘 만들어도 쓰레기 같이 쓰면 결국에는 모든것이 쓰레기가 되기 마련이다.

그래서 알고리즘을 마치 과학에게 있어서 수학같은 존재처럼 가장 기본적이고 필수적인 역량으로 취급하는게 아닐까한다.

## 물론

알고리즘으로 한 사람의 역량을 모두 판별할 수 없다.

그러니 1차 면접으로 알고리즘, 2차 면접으로 포트폴리오를 보는 것이다.

그렇다고 알고리즘은 지긋지긋한데 프로그래밍을 좋아하는 사람이 수학은 싫은데 과학을 좋아하는 사람과 같진 않다. 

물론 최적화하는 방식 중 **하나**가 알고리즘인 점이 분명하지만, 모든 길이 알고리즘으로 통하는 것이 아니다.

언어 자체 내부에 이미 잘 처리되어 있다.

특히 오픈소스의 경우 자신의 능력을 발휘하고 싶어 날뛰는 능력자들이 이미 최적의 기능을 발휘한다.

모든 사람이 알고리즘을 잘할 필요는 없다.

## 덧

컴퓨팅 파워가 물리적 한계 없이 꾸준히 발전한 시대에서는 S/W의 겉보기 성능이 발전한 것처럼 보였다.

언어 자체 설계가 최적화 되면서 S/W의 겉보기 성능이 발전한 것처럼 보였다.

컴파일러가 최적화 되면서 S/W의 겉보기 성능이 발전한 것처럼 보였다.

비동기 프로그래밍이 보편화되면서 S/W의 겉보기 성능이 발전한 것처럼 보였다.

모든 분야가 그렇지만, 소수의 사람이 발전을 이끌어 왔다.

알고리즘을 모르는 사람이 커널처럼 심오한 분야에 진입하지도 못한다.

편안한 추상화 단계가 높은 언어를 사용하는 입장에서 자신보다 능력이 뛰어난 사람의 결과물을 온전히 사용하는 방법 중 하나가

알고리즘을 적재적소에 쓰는 것이라는 생각이든다.
## 유연한 설계

### 개방-폐쇄 원칙 (Open-Closed Principle)

<br>앞서 작성한 [7장 객체분해.md](https://github.com/ccppoo/MyMilitaryServiceLog/blob/master/%EA%B3%B5%EB%B6%80%ED%95%9C%EA%B2%83_%EC%A0%95%EB%A6%AC/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8(Objects)-%EC%A1%B0%EC%98%81%ED%98%B8/7%EC%9E%A5%20%EA%B0%9D%EC%B2%B4%EB%B6%84%ED%95%B4.md#%EC%A0%88%EC%B0%A8-%EC%B6%94%EC%83%81%ED%99%94-b-2-object-oriented)
에서 개방-폐쇄 원칙을 다음과 같이 정리를 했었다.

> 데이터 객체에 직접 접근하는 대신, **사용자에게 주어진 인터페이스로만 접근하도록 제한을 하는 것**이다.<br><br>
> 코드는 인터페이스 양식에 맞게 작성을 하면 변경할 점이 없으므로 수정에 따른 파급효과가 적다. <br><br>
> 인터페이스를 제공하면 클래스의 은닉성을 만족할 수 있기 때문에 객체간 결합도를 낮출 수 있다. <br><br>
> 따라서 객체 내부를 보여줄(Open) 필요가 없으므로(Closed) 개방-폐쇄(Open-Closed) 원칙을 지킬수 있다

<br>워키에서는 [개방-폐쇄 원칙](https://ko.wikipedia.org/wiki/%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84_%EC%9B%90%EC%B9%99)에 대해 
다음과 같이 설명한다.

> '소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, <br><br>
> 수정에 대해서는 닫혀 있어야 한다'는 프로그래밍 원칙이다.

<br>맥락이 어느정도 일치하긴 하는데, **굵게** 표시한 부분만 정정해서 다시 정리를 하자면

**사용자에게 주어진 인터페이스로만 접근하도록 제한을 하는 것**

이 표현은 개방-폐쇄 원칙의 적용범위를 클래스(Class)에 한정지었다.

대부분 객체 클래스에 해당되는 부분이기도 하지만 

JS의 경우 this-binding(bind, apply)을 통해서 함수의 모듈화가 가능하기 때문에 이점을 짚고 넘어가고 싶었다.

![open_closed_diagram](https://github.com/ccppoo/MyMilitaryServiceLog/blob/master/%EA%B3%B5%EB%B6%80%ED%95%9C%EA%B2%83_%EC%A0%95%EB%A6%AC/open-closed.png)

개방(Open), 폐쇄(Closed) 각각 해당하는 의미를 생각해보면 

개방이 폐쇄의 특징을 폐쇄가 개방의 특징을 설명할 수도 있어 "그게 그거 아니야?"라고 할 수 있기도 하다.

...

그나마 체감이 되는 현실적인 예시를 들면

1) [트럭에 견인포를 달아서 자주포를 만들수도 있고](https://namu.wiki/w/%ED%85%8C%ED%81%AC%EB%8B%88%EC%BB%AC?from=%EC%82%AC%EC%A0%9C%20%EC%A0%84%EC%B0%A8)

2) 배달, 운송용으로 (원래 목적) 쓰일수도 있다.

전쟁이 나서 전쟁 무기로 사용할 수도 있고, 전쟁이 끝나면 짐을 실어 나를 수 있는 트럭이 될수 있다

트럭의 화물칸에 무엇을 싣고 다니느냐에 따라 그 기능을 달리한다 (확장)

두 경우 모두 트럭의 엔진이나 운전석과 같은 기본적인 부분은 수정하지 않는다 (폐쇄)

나도 예시를 생각하면서 의미가 다르게 전달될까 걱정은 되지만, 머리속에 그림이 잘 그려져서 예시로 작성해봤다...

<br><br>

### 의존성 역전 원칙

객체지향적 프로그램의 모듈 또는 '개체'들은 수평적인 관계를 갖고 있는다고 했었다.

다만, 코어(Core)에 해당되는, 즉 사회에 있어서 사람같은 존재(사람이 우선 존재하고 사회가 존재하듯이)

인터페이스, 추상 클래스와 같은 개체(컴파일 시점 의존성)들은 추상 클래스를 이용하는 구체 클래스(런타임 시점 의존성)에 비해 우선순위가 높다.


![Dependency_Inversion_Diagram](https://github.com/ccppoo/MyMilitaryServiceLog/blob/master/%EA%B3%B5%EB%B6%80%ED%95%9C%EA%B2%83_%EC%A0%95%EB%A6%AC/Dependency_Inversion.png)

인간 세상에서 사람이 존재하고, 사회가 생겨난다.

사회가 생기면 사람들이 잘 살아가기 위해서 법이 존재한다.

법이 존재하지만, 법은 **사회가 변화함에 따라 지속적으로 수정**된다.

법은 사회, 최종적으로 개인(사회상, 사회적 인식, 문화)에 의존성이 존재한다.

상식적으로 뜬금없이 법이 생기고나서 사회가 구성되고 개인지 생겨나는 것이 아니다.

프로그래밍에 있어서 이 의존성은 거! 꾸! 로! 간다고 생각하면 된다.
<br>(실제 인간 세상과 정반대 방향이라 이해하기 어려웠나보다)

지켜야할 추상화된 개체(인간 -> 법, 프로그램 -> 인터페이스, 추상클래스,클래스)가 존재하고 세부적인 객체가 탄생한다.

다른 객체 클래스들은 **법**만 지키면 된다! 이렇게 세부적인 객체가 아닌 **추상화된 개체**에 의존하는 것이

**의존성 역전**이라고 한다

※ 여기서 말하는 법은 앞 장에서 주구장창 말하는 **책임**과 같다고 볼 수 있다.

### 그러면...

그러면 모듈을 Export할 때 프로그래밍에서는 **법**만 Export하면 되겠지? (아아 그렇다)

메가박스에서 현대카드를 제시하면 10%할인하는 구체적인 클래스를 CGV 프로그램에 까지 들고와서(module import) 쓸 이유가 없다는 것이다

<br><br>

### 유연성 vs 명확성

추상화란 쉽게 말하면 속으로 **'너도 알고 나도 알고 있는 그거... 할게?'**

라고 말하는 것과 같다.

그래서 코드상에서 안보이는게 사실이다 (컴파일 시점 의존성 ≠ 런타임 시점 의존성)

모든게 Trade-Off다.


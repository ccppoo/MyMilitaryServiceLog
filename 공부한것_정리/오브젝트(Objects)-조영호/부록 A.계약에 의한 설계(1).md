# 계약에 의한 설계 (1)

## 서론 - 주저리 주저리

\<오브젝트\>는 읽으면 한 장도 빠짐없이 정리하고, 다시 읽을 가치가 넘치는 내용으로 차있다.

객체지향 프로그래밍에 대한 나의 인식을 바꿔준 책이라는 점에서 인생의 전환점을 선사해줬다.

그만큼 '13장 서브클래싱과 서브타이핑(1)'을 정리하는 글을 쓸 때까지 종이와 사무실 PC에 초안을 쓰면서

내가 나에게 더 와닿는 예시를 작성할 때, 이런 예시가 최대한 보편적 인식으로 바라봤을 때 예외가 생기지 않을까 최대한 제일 추상적인 예시를 들려고 했고(모든 사람이 같은 인생을 사는 것이 아니니깐)

미래의 내가 다시 봤을 때 이 책에 대한 지식이 모두 사라져도 읽어도 이해가 될 수 있게끔 풀어쓰려고 노력했다.

...

이런점 때문에 글은 생각보다 금방써도 고려해야 할 포인트가 많다보니 신경이 많이 쓰인다.

그만큼 생각을 하니깐 힘이 들기도하고, 내가 책을 통해서 머리속으로 정리한 내용이 글로 쓰면 그만큼 표현이 안되면 짜증이 많이 났다.

그래서 다이어그램과 함께 글을 작성하며 머리속 추상화된 개념을 형상의 힘을 빌려 표현하려고 했다.

그렇다고 두달이라는 시간 사이에 이 책을 손에서 놓고 다닌건 아니다.

프로그래밍의 정수, 원론, 다소 철학적인 지식이 그리울때면 이 책의 아무 장이나 펼쳐서

과거의 나의 필기와 함께 처음 읽었을 때 가졌던 질문을 스스로 답하며 책과 과거의 나와 소통하면서 즐겼다.

이제서야 이 책을 마무리 짓기 위해 부록 A부터 C까지 읽고 또 읽으며 정리하려고 한다.

- 2020/09/25 금요일, 북카페에서

## 목차

* 서론

* Design By Contract - C#의 'code contracts'

    * Code Contract의 배경
    
    * Code Contract, 코드 계약
    
    * 정리

* 협력과 계약

    * 부수효과

    * if 문과 계약의 차이

    * 계약의 특징

* 계약에 의한 설계

    * 인터페이스와 계약 - 생김새는 비슷한데 차이는 뭘까

    * 사전조건 - precondition

    * 사후조건 - postcondition

    * 불변식 - invariant

## Design By Contract - C#의 'code contracts'

부록의 첫번째 장, 부록A의 대제목은 '계약에 의한 설계'다.

프로그래밍을 공부하며 계약이라는 단어는 생소했고, 계약이라는 단어를 조금더 확장해서 이해한다면 '모델'이 가까울 수 있겠다.

이번 장을 공부하며 계약에 의한 설계 자체가 곧 모델, 디자인 패턴의 하나라는 것을 알 수 있지만,

'Design By Contract'를 창시한 사람이 "어떤 생각으로 '계약(Contract)'이라는 단어를 생각했을까?"라는 물음에 쫓으며

책을 읽어보면 고개가 절로 끄덕여지게 된다.

프로그래머나 과학자들은 이름을 짓는 능력이 부족하다는 말이 우스겟소리처럼 퍼져있지만,

그 의미를 최대한 만든 사람의 입장에서 만들어가지는 과정을 추적해보면 '그럴 수도 있네!'하고 납득할만한 공감대가 생기게된다.

아무튼 책에서 예시로 든 C#의 라이브러리 'Code Contracts'에 대해서 간단히 알아보자.

### Code Contract의 배경

계약에 의한 설계 'Code Contracts' 클래스는 MS에서 'Tracing and Instrumenting Applications(애플리케이션 추적 및 측정)' 항목으로 분류하고 있습니다.

애플리케이션 내 '트레이싱(추적)'은 프로그램 내 문제를 추적하기 위해서 로깅을 통해서 프로그램의 상황을 모니터링하거나, 오류 또는 에러가 발생하는 경우 문제를 확인하고 해결하는 용도로 쓰이는 행위를 말합니다.

'측정'은 '추적'이 문제를 발견하고 해결하는 것과 반대로 애플리케이션의 성능을 측정해서 발전을 하는 행위를 말합니다.

유지보수를 꾸준히 하는 프로그램이라면 바람직한 행위(버그 유지보수, 성능 개선)가 한 범주로 묶이죠?

뒤에 설명할 Code Contracts가 이런 의도하에 .NET 프레임워크에서 쓰인다는 것을 계속 머리속에 담아두고 읽어주시면 됩니다.

트레이싱과 추적은 다음 네가지 요소로 간략히 분류될 수 있습니다.

    * Code Tracing : 프로그램내 실행(execution)된 것들의 정보를 수신해서 기록하는 것

    * Debugging : 에러 및 버그를 트레이싱해서 해결하는 것

    * Performance Counters : 애플리케이션의 성능을 측정하는 것

    * Event Logs : 애플리케이션 내부에 주요 이벤트를 추적하고 메세지를 수신하는 것

프로그램을 개발중에 유용하게 쓰일 수 있지만, 로깅을 해제하지 않는 경우 민감한 정보가 유출될 수 있으므로 트레이싱 또는 디버깅 옵션을 해제해야 합니다.

참고한 문서 : 

(1) [MS Document - Tracing and Instrumenting Applications](https://docs.microsoft.com/ko-kr/dotnet/framework/debug-trace-profile/tracing-and-instrumenting-applications)

### Code Contracts, 코드 계약

코드 계약은 사용자가 정의한 사전조건, 사후조건, 객체 불변식들을 충족할 수 있도록 도와줍니다.

Visual Studio의 애드온 덕분에 런타임 환경 뿐만 아니라 정적인 환경, 컴파일 타임,에서도 계약 위반 여부를 확인합니다.

정적, 동적 환경 모두 검사가 가능하기 때문에 빠르게 에러를 검출할 수 있고, 계약에 해당되는 코드 자체를 따로 컴파일된 파일을 생성할 수도 있습니다.

    * 사전조건: 메서드 또는 클래스·인스턴스에 접근할 때 요구하는 조건을 의미합니다.<br>
    `(예: Ticket getTickets(int nums)에서 nums > 0 인 조건` 

    * 사후조건: 메서드 또는 클래스·인스턴스 코드가 종료될 때 요구되는 조건을 의미합니다.<br>
    `(예: Ticket getTickets(int num)에서 반환 Ticket 객체가 null이 아닌 조건`
    
    * 불변식(invariant): 클래스·인스턴스의 '정상'이라고 판단되는 조건을 의미합니다.<br>
    `(예: 생성된 Ticket 인스턴스의 string Name 필드는 null이 아닌 조건`

코드 계약의 장점은 다음과 같습니다

    * 컴파일 타임, 런타임 환경 모두 지원 (VS 애드온에서 지원)
    
    * 코드 계약이 명시되어있기 때문에 예외 케이스를 위한 유닛 테스트 불필요
    
    * 문서화 편리함 - XML 문서 생성해줌

define 해더를 통해서 코드 별로 계약의 채결 유무를 결정할 수 있습니다.


참고한 문서 :

(1) [MS Document - Code Contracts](https://docs.microsoft.com/ko-kr/dotnet/framework/debug-trace-profile/code-contracts)

(2) [MS Document - Contract Class](https://docs.microsoft.com/ko-kr/dotnet/api/system.diagnostics.contracts.contract?view=netcore-3.1)

### 정리

계약에 의한 설계(이론)를 알아보기 전에 이미 존재하고, 쓰이는 C#의 Code Contracts에 대해 간단히 알아봤습니다.

코드 계약 모듈을 사용하는 스크립트만 Github에서 26만개(2020.9.25 기준)의 존재합니다.

계약에 의한 설계는 단순히 if 문을 통해 사전·사후조건을 검증하기 전에 쓰이는 것 외에 테스트, 타이핑 검사에 유용합니다.

계속해서 계약과 if 문의 차이 그리고 설계 디자인에 있어 특징에 대해서 알아보겠습니다.

## 협력과 계약

### 부수효과

메서드 파라미터에 명시된 계약을 통해서 문서화를 할 때 편리함이 존재한다.

그리고 계약 모듈을 사용함에 따라 명시적으로 메서드의 타입과 조건을 명시적으로 표시할 수 있다.

언어 마다 Contract 모듈을 설계하는 것에 따라 다르지만,

계약 조건 플래그를 통해 문서화를 지원할 수 있다.

### if 문과 계약의 차이

계약 모듈은 함수 진입과 탈출 부분에서 파라미터의 조건(계약)을 지키도록 도와준다.

return 문이 여러개 있는 메서드의 경우 매번 if 문을 작성할 것인가?

항상 지켜야하는 조건, 불변식(invariant)의 경우 메서드 내부에서 변수의 대입이 일어날 때 매번

assert 문, if 문을 작성할 것인가?

if 문은 **국지적**인 반면 코드 계약은 **전면적**으로 코드 제약을 한다.

그래서 if 문은 개발 단계/ 릴리즈 단계에서 제약을 변환하는 것을 모두 수동으로 해야한다.

### 계약의 특징

계약은 두 명이상의 당사자간에 문서화된 의무와 이익이 있다.

한 쪽의 의무는 다른 한 쪽의 이익이 되며 둘 사이에 협력을 요구한다.

객체지향, 객체지향 프로그래밍에서 계약자와 피계약자를 나누자면

객체지향적인 코드를 작성하는 프로그래머와 그 코드를 사용하는 다른 프로그래머다.

혼자 프로그래밍을 하는 경우, 코드를 작성하는 **나** 자신과 현재 내가 작성한 코드를 사용할 '**미래의 나**' 사이에 계약을 맺는 것이다.

문서화된 계약은 객체지향적으로 작성된 **코드**이며, 객체지향적으로 작성한 코드를 사용할 수 있는 미래의 내가 얻는 것이 이득이다.

늘 코딩을 할 때는 현재 코딩을 하며 갖고 있는 지식이 미래의 내가 이 코드를 다시 봤을 때, '현재 내가 알고 있는 것들을 온전히 기억할 수 있는지'를 보장할 수 없다는 사실을 인지해야한다.

현재의 내가 만든 계약으로 인해 얻는 이익은 미래의 내가 객체지향 코드를 이용해 코딩을 했을때, 

먼 미래의 내가 계약에 명시된 조건을 통해서 더 빠르게 코드 구조를 분석하거나, 디버깅을 더 쉽게 인지할 수 있다는 것이다.

## 계약에 의한 설계

### 인터페이스와 계약 - 생김새는 비슷한데 차이는 뭘까

```Java
public Reservation reserve( Customer customer, int num, ReserveType type){
    // ...
}
```

정적 타입을 지원하는 자바의 함수를 보면,

메서드를 클래스 외부에서 사용가능 여부, 반환하는 값의 타입, 메서드의 이름, 인자의 개수와 타입을 확인할 수 있다.

메서드에 이렇게 명시적으로 보이는 조건만으로 충분하지 않은가? 할 수 있다.

계약은 여기에 클래스의 필드 값 조건, 정수의 크기, not null, 등등... 메서드 파라미터 타입을 제한하는 것을 포함해

반환값의 조건, 그리고 객체 내부 상태의 조건을 감시를 통해 특정 값이 정상 범주를 넘어서면 에러를  던질 수 있어 전체적인 코드 질의 향상과 편한 버그 트레이싱이 가능하다.

##### 여기서부터 예시코드는 파이썬으로 작성되었습니다

파이썬은 정적인 언어가 아니기 때문에 타입검사가 되지 않고, 메서드에 타입을 명시해도 그대로 실행되기 때문에<br>
(언어 자체에 있어 오류는 아님)

계약에 의한 설계의 예시로 들기 적합하다는 판단이 들어 작성했습니다.

그리고 Contract을 이용한 함수, 클래스는 실제로 존재하지 않는 것으로 보기만해주세요.

### 사전조건 - precondition

사전조건은 메서드가 실행되기 전 만족해야하는 조건이다.

인자의 타입과 인자 타입의 조건이 있다.

인자 타입이 메서드에서 요구한 타입은 타입의 조건을 만족해야지 실행이 된다.

```python
class Hotel:

    @Contract.Requires(name != None and room.isinstanceof(HotelRoom))
    def makeReservation(self, name, roomClass):
        # ...
        return Reservation(name, roomClass)
```

### 사후조건 - postcondition

사후조건은 메서드가 실행되고 그 결과가 올바른지 검사하고, 메서드를 실행한 객체들이 정상 상태에 있는지 검사하는 것이다.

```python
class Hotel:

    @Contract.Requires(name != None and room.isinstanceof(HotelRoom))
    @Contract.Ensures(Contract.Result.Reservation is not None) # 반환된 Reservation 인스턴스가 None이 아닌 것을 보장
    def makeReservation(self, name, roomClass):
        # ...
        
        # 예약이 정상적으로 시행되었으면 남는 방의 개수는 이전보다 줄어들어 있을 것이다
        Contract.Ensures(self.rooms < Contract.OldValue.[self.rooms])
        return Reservation(name, roomClass)
```

객체에 메세지를 전달하는 클라이언트(메서드 호출 코드)는 사전조건에 명시된 조건만 만족하면 의무를 모두 만족한 상태다.

인자를 건너받은 메서드(서버)가 계약에 명시된 조건을 충족시켜야 하고, 충족되는 조건이 없는 경우

계약에서 합의된 에러를 던지거나, 프로그램이 오작동하지 않도록 중단시켜야한다.

C#의 계약 모듈은 변경된 인자의 값이 변경 후에도 초기의 값과 비교할 수 있어 변화의 유무를 확인할 수 있다.

예시로든 makeReservation 메서드가 정상적으로 작동한 경우 Hotel 객체의 남는 방이 반드시 1은 줄어야하는 상태를 확인하는 것이다.

### 불변식 - invariant

객체의 메서드를 실행 유무와 상관없이 항상 지켜져야하는 조건식을 의미합니다.

```python
class Hotel:

    @Contract.Requires(name != None and room.isinstanceof(HotelRoom))
    @Contract.Ensures(Contract.Result.Reservation is not None)
    @Contract.Invariant(self.room >= 0) # 방의 개수는 음수가 될 수 없다.
    def makeReservation(self, name, roomClass):
        # ...
        
        Contract.Ensures(self.rooms < Contract.OldValue.[self.rooms])
        return Reservation(name, roomClass)
```

Hotel 클래스 예시같은 경우, 남는 방은 무조건 0 또는 자연수인 상태를 유지해하는 것과 같습니다.

-------

다음 글에서...

* 계약 규칙

    * 서브타입에 **더 강력한 사전조건**을 정의할 수 없다
    
    * 서브타입에 **더 완화된 사후조건**을 정의할 수 없다
    
    * 슈퍼타입의 불변식은 서브타입에서도 반드시 유지되어야 한다
    
* 가변성 규칙

    * 서브타입은 슈퍼타입이 발생시키는 예외와 다른 타입의 예외를 발생시켜서는 안된다
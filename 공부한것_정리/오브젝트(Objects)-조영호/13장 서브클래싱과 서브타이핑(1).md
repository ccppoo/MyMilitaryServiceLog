# 서브클래싱과 서브타이핑 1편

서브클래싱과 서브타이핑이라는 단어를 들어본 적이 거의 없다.

이 책을 읽지 않았다면 "상속(확장)이면 상속이지 서브클래싱은 뭐야?"라고 말했을 것 같다.

서브클래싱(Sub-Classing)과 서브타이핑(Sub-Typing)은 모두 서브(Sub-)를 접두어로 사용하고 있다.

여기서 서브(Sub)은 평상시 많이 쓴 부모클래스, 서브클래스, 또는 슈퍼클래스와 정반대의 **관계**를 의미하는 자식(클래스)을 의미한다.

-------

클래스와 인터페이스를 상속하는 그림은 A와 같이 표현한다.

화살표로 그 관계를 나타내고 화살표의 출발지점이 상속을 받는 클래스(Sub Class),

화살표의 도착 지점이 상속이 되는 클래스다 (Super Class).

![Imaging subclass and superclass](https://github.com/ccppoo/MyMilitaryServiceLog/blob/master/%EA%B3%B5%EB%B6%80%ED%95%9C%EA%B2%83_%EC%A0%95%EB%A6%AC/Imaging_subclass_and_superclass.png)

직관적인 표현을 위해서 대부분 슈퍼 클래스가 위에, 서브 클래스가 아래에 위치한다.

슈퍼 클래스에서 갈라져 **특수화**된 클래스들은 수평적인 관계로 취급해 나란히 놓인다 (부모 - 형제 관계).

하지만, 나는 화살표로 표현한 그림보다는 벤다이어그램으로 나타내는 것이 직관에 더 들어 맞았고,

벤다이어그램으로 나타내는 것이 상속의 근본을 더 잘 드러내는 표현이라고 생각한다.

### 그럼 왜 그렇게 생각하니

#### 1. 프로그래밍하는 것도 힘들고, 그리는 것도 힘들고

일단 벤다이어그램을 통한 표현은 그리기가 매우 힘들다

그래서 클래스를 2~3개 상속을 하면 뭔가 잘못되었음을 깨닳는다.

클래스를 여러번 상속을 한다고 *객체 지향적*인 프로그래밍이 아니다.

마치 다이어트 식단 조절 음식을 하루 세끼가 아니라 마구잡이로 먹는 것과 같은 의미다.

상속(확장)을 할 슈퍼클래스는 여러 클래스들의 공통 분모를 찾아서 간추린 것이라고 간단하게 말 할 수 있다.
<br>(*2편에서 이야기할 서브클래싱의 방법)

마치 데이터베이스 정규화 같은 과정을 통해서 코드양을 줄이고 모듈화를 하면 좋은 방법이라고 볼 수 있다.

하지만, 상속은 클래스가 가지고 있는 필드값, 메서드를 모두 빠짐없이 책임져야하는 요소들이다.

코드 양을 줄이겠다고 여러 단계에 걸친 상속을 하면 그만큼 책임을 져야하는 양이 증가한다.

책임을 져야하는 만큼 힘들다. 마치 벤다이어그램을 그리듯이 말이다.

유연하고 결합도가 낮고 응집도가 높은 코드는 만능 해결사가 아니다.

그리고 막연하게 상속을 많이 한다는 것이 옳바른 방법이 아닐 가능성이 높다.

설계상 결합도와 응집도는 Trade-Off의 결과다.
(※ [9장 유연한 설계](https://github.com/ccppoo/MyMilitaryServiceLog/blob/093614b5151eafd3b473285f23ca997847a38731/%EA%B3%B5%EB%B6%80%ED%95%9C%EA%B2%83_%EC%A0%95%EB%A6%AC/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8(Objects)-%EC%A1%B0%EC%98%81%ED%98%B8/9%EC%9E%A5%20%EC%9C%A0%EC%97%B0%ED%95%9C%20%EC%84%A4%EA%B3%84.md) )

아무리 상속을 옳바르게 쓰고 모든 것을 인터페이스화 한들, 

프로그래머가 읽기 힘든, 런타임 의존성이 매우 높은, 코드는 무조건 좋다고 볼 수 없다.
<br>*문서화(Documentation)를 엄청 잘하면 상관없다*


#### 2. 시각적으로 '확장'했다는 걸 볼 수 있음

상속이라는 말은 사람이 죽고 물려준 것을 받는 행위다.

사람에게 상속이라는 표현을 쓴다. 죽어있는 사람과 살아있는 사람은 엄청난 차이가 존재한다.

그럼에도 상속한 클래스로부터 모든 것을 받고, 상속한 클래스의 특성을 이용한다는 점을

처음 객체지향 프로그래밍을 배우는 사람이 납득 할 수 있을까?

...

벤다이어그램은 상속한 클래스를 내부에 포함된 것을 볼 수 있다.

상속할 클래스에서 일부만 쓰겠다고 일부만을 떼어 쓴다는 것을 상상하긴 힘들다.

클래스의 중심부에 위치하므로 주고 받는 영향에 있어 상속된 다른 클래스들간에 걸친 영향력을 파악할 수 있다.

### 근데 이걸 이렇게 말할정도로 중요하니

내가 모르는 누군가 이 글을 봤을 때 반드시 알아가야 한다면 그건 아니다.

사람마다 이해하는 방법이 다를 수 있고, 나는 특히 기하학적으로 표현하는 것이 쉽다고 생각하기 떄문이다.

이번 장에서 클래스(추상클래스)와 인터페이스 상속(확장)에서의 **서브클래싱**과 **서브타이핑**을

기하학적으로 구분하기 좋아 1장에서 설명했다.

## 덧

현실 '인간'의 추상적인 개념을 프로그래밍적으로 풀어 쓴다는 건 쉬우면서도 어려운 일이다.

'캐치마인드'라는 게임을 봐도 알 수 있듯이 사람들은 본인들이 떠오르는 사물에 대해서

중요하다고 부각되는 부분을 중점으로 그려서 해당 물건을 말한다.

딥러닝은 인간의 추상화를 평균낸 것을 저장한 모방지능이다.

객체지향적 프로그래밍도 이와 비슷한 맥락위에 있다.

다른 사람들도 공감하고 있을법한 속성을 지닌 클래스를 작성하는 것이 **객체지향적** 프로그래밍이다.

다른 사람의 '추상화'를 이미지처럼 스냅샷을 본 떠 코드 몇줄로 간단히 남긴것이다.

머신러닝은 작동방식과 구현하는 방법이 어려울 뿐이지 그 개념은 평상시에 계속 쓰이는 것이다.

...

## 다음편

추상화 : 

> "너 **그거**하고 **그거** 들어있고, **그렇게** 작동하는 거 알지?"


추상화 + 객체지향적 프로그래밍 : 

> "너 **구성 품목 리스트**에 들어있는 거 보고, **작동 메뉴얼**대로 작동하는 거 알지?"


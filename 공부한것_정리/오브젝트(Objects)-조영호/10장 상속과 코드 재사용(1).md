# 상속과 코드 재사용

반복되는 코드를 재사용하는 의지는 프로그래밍의 패러다임과 관계없이 나타나는 현상이다.

반복되는 코드가 데이터 형태의 경우 함수가 아닌 class, struct와 같은 데이터 형(形)의 재사용이 이뤄진다.

그 방법중 하나는 잘 알려진 클래스의 확장, **Extends**와 **Implements**가 있다.

## Extends, Implements

<br>

책 <오브젝트>와 함께 복습, 익습용으로 같이 보는 영상에서 나오듯이 : 
[코드스피츠 84 오브젝트2 - 1회차](https://www.youtube.com/watch?v=vSnFC2x-RYE&list=PLBNdLLaRx_rLOQsMCWxvawSUVI6cXoMsk&index=2&t=1287s)

나도 Extends라는 단어를 "**상속**"이라고 부르는 것에 대해 고개가 갸우뚱했다.

상속은 누가 죽어서 그 소유물을 물려 받는 행위인데... 피상속 클래스를 다른곳에서 못 쓰는 것도 아니고...

그래서 나는 "**확장**"이라는 표현이 더 체감이 잘 된다.

인터페이스(interface)를 확장하는 Implements의 동사형을 한글로 '상속(하다)'이라고 인터넷상에서 부르는데

Implements는 코드가 "**규칙을 지킨다**"라는 표현이 더 옳다.

implements는 클래스가 꼭 가져야 할 메서드를 명시해놓는 것일 뿐이기 때문이다.

상속이라면 돈이나 자동차 같이 실물, 또는 실체가 없는 무형 자산(빚)이라도 **받지만**

법은 개인의 소유물 또한 아닐 뿐더러 받는게 아니라 **지키**는 것이지, 표현상으로 법을 상속한다는 건 전무하다.

...

Class와 interface 모두 **확장**할 수 있다(extends)

그래서 이하 서술하는 내용들에 대해서 'Class의 확장한다~'는 표현을 쓰게되는데,

Class만 해당되는 이야기가 아니라 

Class와 interface 모두 적용되는 하나의 개념이라고 이해하는 편이 좋을 것 같다.
<br>*(아무래도 class를 확장하는 경우가 많다보니...)*

※이제보니 Swift를 공부했을때, 왜 interface를 protocol(규약)이라고 부르는지 이해할 수 있었다.

# 아차

내가 작성할 클래스의 모든 공통점을 추려서 하나의 코어(Core) 클래스를 만들고,

코어 클래스를 상속하면 그만큼의 코드 중복을 만들 수 있을 것 같아 싱글벙글 새로운 클래스를 만들고 있다.

하지만, 영원하거나 절대적인 것은 *거의* 없고, 내 코드는 해당되지 않아서 비극을 맞이하는 경우가 종종있다.

아래 도형도에서 나오는 <ins>2가지 문제점</ins>과 이를 <ins>해결하는 방법</ins>으로 글을 읽게 될것이다.

...

아, 물론 이론상으로는 못할 일은 없다. 

다만, 문제에 봉착하면 문제를 해결하는 방법의 방향을 제시하는 책을 내가 다시 정리한 것이므로

Cheat Sheet이라긴보다 제안(proposal)라고 생각해주면 좋겠다.

![extension_situation](https://github.com/ccppoo/MyMilitaryServiceLog/blob/master/%EA%B3%B5%EB%B6%80%ED%95%9C%EA%B2%83_%EC%A0%95%EB%A6%AC/extend_1.png)


## 1) 영원할 것 같은 객체

ㅎㅇ, 보편적인 개발자들이라면

"아 이건 근본인데 안바뀌지 ㅋㅋ 설마 바뀌겠어?" 라고 생각하며 클래스를 작성하고 상속하다가 나중에

메서드 이름이 겹쳐서, 이름이 별로여서, 기능이 이건 좀 아닌것 같아서, .. 등등 여러 이유로 수정하게 된다.

객체에 toString, Hashcode, equals와 같은 필수적인(또는 생각하는) 메서드는 어느 클래스에나 있을거라는 생각에 상속할 수 있다.

stack에 있는 기능 push, pop의 기능이 list에 쓰인다고 list가 stack 클래스를 확장하는 경우도 있다.

이렇게 글로 읽으면 이상하다는 것을 눈치 챌 수 있지만, **일단 코드가 돌아가기만 하면**하는 마음이 언제나 있기 때문에

잠재적인 위험이 도사리고 있다.

마치 아프리카 원주민 또한 한국 사람처럼 똑같이 인사를 나눌거라는 생각하에 손을 흔들어 인사를 하다가

모욕으로 취급되어 창에 맞을지도 모르는 일이 벌어질 수 있기 때문에 

같은 기능이랄지도 그 깊은 뜻, 개발자의 의도가 다를 수 있기에 무분별한 상속은 위험하다.

## 2) 피상속 클래스가 수정되는 경우

![](https://github.com/ccppoo/MyMilitaryServiceLog/blob/master/%EA%B3%B5%EB%B6%80%ED%95%9C%EA%B2%83_%EC%A0%95%EB%A6%AC/extend_2.png)

A + B -> C ... α + B -> C (?)

B 클래스가 A 클래스를 상속하여 C 클래스를 만들었다고 하자.

근데 A 클래스가 변경되어 α 클래스가 되어도 C 클래스가 그대로 존재할 수 있다는 것을 보장할 수 있을까?

상위 클래스의 메서드를 직접적으로 사용하는 경우 상속과 동시에 강하게 결합되기 때문에 결합성 때문에 강한 파급효과가 일어난다.

즉, 객체간 결합성과 같은 효과가 일어난다.

복잡한 클래스 또는 B와 같이 A를 상속 한 클래스들이 10개씩 있다면 수정할 사안이 최소 10번은 된다는 의미다.

수정하면 A를 상속하는 모든 클래스에 파급효과가 없다는 것을 보장할 수 있는가?

## 3) 상속 클래스의 본질이 피상속 클래스에 어긋나는 경우

![](https://github.com/ccppoo/MyMilitaryServiceLog/blob/master/%EA%B3%B5%EB%B6%80%ED%95%9C%EA%B2%83_%EC%A0%95%EB%A6%AC/extend_3.png)

클래스를 상속, 확장한다는 것은 기존의 것을 재활용한다는 의미를 내포하기도 한다.

재사용하는 건 좋은데, 그 의미와 원래 본질 또한 그대로 갖고 있어야한다.

Human 클래스를 상속했는데, 같은 포유류라고 Dog 클래스가 Human 클래스를 상속해선 안된다는 것이다.

솔직히 말해서 인간이 개가 되는 건 가능하다(**기능상**).

힘들겠지만 손을 발처럼 이용해서 4발로 이동하는 것도 가능하고, 

Dog 클래스에 꼬리 특성 필드값(?!)이 있다면 꼬리를 다는것도 가능하다.

안될건 없는데 아상하다. 그리고 이렇게 상속하면 안되는 것을 본능적으로도 느낄 수 있다.

인간(Human)이 할 수 있는 모든 것을 할 수 있는 개(Dog extends Human)이라니 이상하다.

...

과격하고 이상한 예시지만, 이런 경우가 자바에도 존재한다.

List와 유사한 [Vector 클래스의 문서](https://docs.oracle.com/javase/8/docs/api/java/util/Vector.html)를 보면

Direct Known SubClasses에 Stack이 존재한다.

[AbstractList ⊃ Vector ⊃ Stack]과 같은 상태다. 

stack이 vector의 기능 중 add(int index, E element)를 쓸 수 있는 것이다.

LIFO(Last in First Out) 특징을 가진 stack이 중간삽입이 가능하다니?







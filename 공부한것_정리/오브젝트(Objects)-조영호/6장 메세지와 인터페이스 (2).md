### 글을 시작하기 전에

이 책을 최대 2일 이상 놓은 적은 없었다.

오브젝트는 읽으면 너무 당연한 이야기를 매우 세세하게 풀어서 쓴 것 같아 정리를 어떻게 써야하나 늘 고민이 있었다.

추상적인 개념을 불문법에서 성문법으로 정리하는 같은 과정을 거치는 거라 생각의 과도기(?)를 거친것 같다.

장대한 내용을 짧게 정리하자니 참 낮간지럽기도 하고 추상적인 것을 더 축약하자니 어렵다...

태블릿만 사면 직접 개발을 하고 스스로 코드 리뷰를 하며 차차 복습할 생각이다.

## 객체 상대성이론

객체는 협력의 노드(Node)다.

마치 생명체가 하나의 세포에서부터 조직, 기관, 기관계를 이루듯이 필요한 것을 요청하면서 상호작용을 이룬다.

객체 A가 다른 객체 B에게 **어떤 행위를 요구**를하면 A는 클라이언트(Client), B는 서버(Server)라고 한다.

객체 B가 요구받은 요청을 처리하기 위해서 객체 C에게 요청하면 B는 클라이언트가 된다.

즉, 마치 상황에 따라 역할(Role)이 바뀌듯이 객체의 역할 또한 상대적으로 바뀐다.

------

객체가 작동하는 방법은 메세지(Message)와 메서드(Method)로 분류될 수 있다.

보편적으로 메서드라는 말을 객체에 존재하는 함수로 통칭하는데 메세지와 메서드를 통칭해서 "함수"라고 부르겠다

**메세지**
  * 메세지는 외부에 노출되는 함수다
  * 메세지는 다른 객체가 호출하고 객체 인스턴스 내부 사정을 신경쓰지 않는다.
    * 메세지는 객체 인스턴스 간의 소통을 UDP처럼 한다고 생각하면 이해하기 편하다
    
      일단 메세지를 보내고 수신자 객체가 받았다고 생각하고 그 리턴값을 기다리는 것...
  * 객체 내부 상황을 노출하지 않기 때문에 추상적이다. (누가 봐도 어떤 일을 하는지 알수있는 함수) 
    * 그렇기 때문에 인터페이스를 통해서 접근하는게 정상적이다.
  * 객체 내부 상태를 제어/조작을 최소화로 하는 것이 좋다(부수 효과↓).

**메서드**
  * 메서드는 외부에 노출되지 않는다.
  * 메서드를 사용하기 위해서 객체 상태를 알고있어야한다.
  * 객체 스스로가 호출(this.<Method>() )하는 편이다.
  * 메서드는 객체 내부 상태를 제어한다.
    * 그렇기 때문에 외부에 노출되지 않는(private, protected) 것이 안전하다.
    
대략적으로 간추리면 

메세지(Message)는 순수한 함수와 같이 작동하는 것이 좋다.

메서드(Method)는 부수효과를 낳는 함수와 같이 작동한다. 

![Message and Method](https://github.com/ccppoo/MyMilitaryServiceLog/blob/master/%EA%B3%B5%EB%B6%80%ED%95%9C%EA%B2%83_%EC%A0%95%EB%A6%AC/MessageAndMethod.png)

<정리한 다이어그램>

------

인터페이스란 세부적인 객체를 추상화하기 위한 중계장치와 같다.

추상적인 인터페이스는 객체와 객체간에 호출할 때 객체의 역할(Role)에 상관없이 알아 들을 수 있는 수준을 말한다.

'추상적'이라는 말 그대로 누구든(어떤 객체든간에) 언제 호출하든간에 어떤 효과/리턴값이 발생/돌아오는지 파악할 수 있는 수준을 말한다.

인터페이스 함수들은 보편적인 의미에서 알아 들을 수 있도록 작성해야한다.

함수이름은 **목적지향적**으로 작성한다.

**과정**이나 : *getMoney FromBank()*

**조건여부**는  : *getMoney IfnoCash()*

일반화되지 못해있다.

*목적지향*적으로 *getMoney*처럼 작성해야한다.

나머지 세부 조건이나 과정은 인터페이스를 implement하는 객체가 알아서 작성할 것이다.

-------------

### 디미터의 법칙

객체는 단순한 데이터 Holder가 아니다.

'''JS
Student Tom = new Student("Tom");
Tom.getBag().getBook().WriteSomething("hehehe");
'''

이렇게 직접 호출 후 제어하는 것은 객체의 자율성을 해치고 나중에 객체가 수정될 때 줄줄이 코드가 망쳐지는

기차 충돌(Train Wreck)이 일어난다.

다만, List와 같은 자료형에서 점(Dot, '.')으로 줄줄이 이어지는 경우가 있는데

```JS
[1,2,3,4].forEach(x=> x*x).filter( x => x%2).sum()
```
같은 경우 

```JS
[1,2,3,4].forEach(x=> x*x) // returns LIST

[1,2,3,4].forEach(x=> x*x).filter( x => x%2) // returns LIST

[1,2,3,4].forEach(x=> x*x).filter( x => x%2).sum() // execute List Method, returns NUM
```
처럼 같은 자료형을 반환하기 때문에 디미터의 법칙을 어기는 것이 아니다.

```
Tom.getBag() // returns class <Bag>

Tom.getBag().getBook() // returns class <Book>

Tom.getBag().getBook().WriteSomething("hehehe") // execute Book Method, returns void
```
위처럼 객체 A가 B를 부르고, B가 C를 부르고... 줄줄이 이어지는 상태를 기차 놀이(나쁜거)라고 한다.

### 급 결론

묻지말고 시켜라

부수효과가 발생하는지, 안하는지 구분을 두자 (비순수함수 / 순수함수)


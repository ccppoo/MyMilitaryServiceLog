## The Main Thread is Overworked & Underpaid (Chrome Dev Summit 2019)

Youtube - [The main thread is overworked & underpaid (Chrome Dev Summit 2019)](https://www.youtube.com/watch?v=7Rrv9qFMWNM&list=LLle727HJuGdiXQ_x5CtXlHw&index=3&t=0s)

영상 대략 정리한 내용과 알아야 할 것

영상 내용이 설명을 위해서 Google-Proxx와 병행해서 설명하는 방식이라 직접 영상을 보면서 이해를 하도록...

------

전세계의 인터넷의 보급률은 높아지지만, 하이엔드 기기의 보급은 그 수준을 미처 따라가지 못한다.

대표적으로 인도, 그리고 다수의 아프리카의 국가들은 인터넷 보급률이 높아짐에 따라 사용자수들이 급격하게 증가하는 Emerging Market이다.

인터넷이 보급되었음에도 불구하고, 인터넷 속도는 한국의 평균 속도에 비해 터무니 없이 느리다.

이런 상황은 낮은 사양의 핸드폰을 갖는 선진국 사용자들에게도 해당된다.

### 빠르게, 빠르게

웹은 단지 html 요소를 보여주기 위한 기능만 존재하는 것이 아니라 

확장 앱, 게임, 그래픽, 등 복잡한 연산작업을 요구하는 서비스들이 많이 존재한다.

120 hz 주사율(초당 120 프레임)을 제공하는 기기들이 등장함에 따라서 브라우저의 작업을 더 빨리 처리해야 할 필요가 생겼다. 

60 hz 주사율을 제공하기 위해서는 모든 작업이 1/60 (초) ≒ 16ms 안에 처리되고, 사용자의 상호작용을 반영하여 UI를 업데이트 해야한다.

16ms에  Event, JavaScript, Styling, Layout, Painting, Compositing(합성)을 모두 처리해야 한다.

즉 이말은 120 Hz 환경에서는 기존에 16ms에 수행되어도 가능한 작업을 8 ms에 처리해야 된다는 것을 의미한다.

JavaScript 코드에 CPU Hungry Task(Blocking 함수)가 많이 있는 경우, 화면은 16ms마다 업데이트를 보장하지 못하고

일반적으로 화면이 **얼어버리는(Freeze)** 현상이 일어나게된다 (아 인터넷 멈췄어)

이런 현상은 사용자 경험(UX)에 나쁜 영향을 끼치고 결국 안쓰이게 된다.

### 혹사 당하는 Main Thread

Main Thread가 이 모든 작업을 수행할 수도 있다.

일반 Native App과 달리 멀티 스레딩을 할 수 없기 때문에 모든 작업을 메인 쓰레드에 때려넣을 수 있지만,

이는 결국 스레드로 작업을 분산시키지 못하기 때문에 기기 성능에 전적으로 맡기게 된다.

고사양 최신 기기(Galaxy S20, iPhone X 11)는 단일 쓰레드 작업이라도 프로세서 사양이 좋기 때문에 

같은 작업이더라도 16ms보다 적게 걸릴 수 있어 문제 없어보일 수 있지만,

개발도상국 같은 곳에서 많이 사용되는 저사양기기의 경우 초당 60 프레임을 보장 할 수 없다.

수억명이 있는 잠재시장이 있는 현재 세계에서 많은 사용자를 잃을 수 있다...

### 그래서

모든 작업을 Main Thread에 때려박았다간 **작업이 16ms 내 완료(60hz)** 또는 **좋은 UX**(자연스러운 화면,Freezing X)을 보장하지 못한다.

모든 작업을 한번에 다 할 필요는 없다.

사용자들에겐 웹이 아직 살아있고, 작동 중인지 인지할 수 있는게 제일 중요하다

60hz환경에서 일반적으로 200ms 걸리는 작업을 100개로 나눠서 16ms * 100 = 1600ms (1.6초)를 걸려서라도 제공하는 것이 좋다.

화면이 뚝뚝 끊기면서 0.2초만에 보여지는 것 보다,

초당 60 프레임을 제공하면서 1.6초만에 작업이 완료되는 것이 훨신 나은 것이다.

### Main Thread는 UI 작업만

Main Thread 즉 웹에선 Web Worker가 아닌 스크립트에서는 UI만 업데이트(DOM 조작)하는 작업만 존재하는 것이

사용자 경험에 있어 더 나은 결과를 낸다.

이미지를 픽셀마다 제어하는 반복적인 연산이 필요로하는 경우 Web Worker나 Web Assembly를 쓰는 것이 좋다.

JS는 Single Process Single Thread이다!!

### 덧,

스레드간에 오브젝트를 전달 할 때

걸리는 시간 ∝ 객체의 복잡함 -> 깊고, 중첩된 객체

걸리는 시간 ∝ 객체의 크기(길이)

## 정리

* UI는 Main Thread만 제어할 수 있다. 다른 일을 시키지 말자
  * Model, View, Control 패턴에서 View는 Main Thread, Model과 Control는 다른 스레드로
* 120hz는 백엔드 작업을 2배로 더 빨리해야한다는 의미다.
  * 작업에 소요되는 시간을 줄일 수 없으면 쓰레드(웹의 경우 - Web Worker)를 사용하자
* Main Thread가 널널하면(UI작업만하면) Google - Light House 점수를 높게 받을 수 있다
* 사용자들은 작업이 느리게 되는 한이 있더라도 화면이 멈추는(Freezing)것을 받아 들일 수 없다.
  * 무조건 작업을 빠르게 하는게 중요한게 아니다, 사용자가 앱이 '멈췄'다고 느껴지지 않게 하는게 중요
